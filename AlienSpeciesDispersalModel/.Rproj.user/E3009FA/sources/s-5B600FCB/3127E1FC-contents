#needs matrix of parameters. should call parameters by name (via colnames(matrix)).
#  Needs parallelization already? If so, folder structure needed to save results of each run separately.
# parallelization not needed yet for parameters, might be useful for networks at a later stage.

# file_init: either the name of the file to be created by InitializeSpread(),
# or the FULL path of the file to be read in (created by InitzializeSpread() or ModelSpread() ).
# In both cases, MUST BE an .Rdata file!

SpreadModel <- function(parameters,internal_dataset=TRUE,initialize=TRUE,file_init="init_data.Rdata",save_init=TRUE,
                        dir_data=NULL, netw_data=NULL,Rdata_file=NULL,init_coords, num_iter,
                        incl_attachment=T,incl_airflow=T,LandCoverID,max_dist=1000,
                        makeplot=F, iter_save=num_iter){
  ####################################################################

  tmp <- proc.time()

  dir.name<-file.path(getwd(),format(Sys.time(), "%d-%b-%Y %H-%M-%S"))
  dir.create(dir.name)

  if (initialize==TRUE) {
  init_data<-InitializeSpread(init_coords=init_coords,max_dist=max_dist,save_init=save_init, save_dir=dir.name,file_init=file_init)
  } else {cat("\n Loading initialization data \n")
    load(file_init)
  }

  road_netw<-init_data[[1]]
  node_state<-init_data[[2]]
  init_segm<-init_data[[3]]

  ## add opposite direction (only mean values in both directions are provided so far)
  # road_netw_otherdir <- road_netw
  # names(road_netw_otherdir) <- c("FromNode","ToNode","Length","Type","Traffic")
  # road_netw_otherdir[,ToNode:=road_netw[,FromNode]]
  # road_netw_otherdir[,FromNode:=road_netw[,ToNode]]
  # road_netw <- rbind(road_netw,road_netw_otherdir)

  ## transform measures into a single dispersal probability
  # Events are considered non mutually exclusive.

  #road_netw[,disp:=0]

  # if (include_traffic) {road_netw[,p_traff:=f_traff(Traffic,traf1)]
  # road_netw[,disp:=disp+p_traff]
  # }

  for (nparset in nrow(parameters)){
    #get PI for segment
    cat("\n Calculating Probability of Introduction for each segment \n")

    road_netw[,p_natural:=f_natural(Length,parameters[nparset,"nat1"],parameters[nparset,"nat2"] )]

    if (incl_attachment) {
      road_netw[,p_attach:=f_attach(Length,parameters[nparset,"att1"],parameters[nparset,"att2"],parameters[nparset,"att3"])]
      road_netw[,p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"pickup_prob"])]
    }
    if (incl_airflow) {
      road_netw[,p_airflow:=f_airflow(Length,parameters[nparset,"air1"],parameters[nparset,"air2"])]
      road_netw[,p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"pickup_prob"])]
    }

    col_prob<-road_netw[,.SD,.SDcols=grep("p_",colnames(road_netw))]

    road_netw[,Pi:=apply(col_prob,1,pUnion)] #prod by row

    #get PE for segment

    cat("\n Calculating Probability of Establishment for each segment \n")

    LCprop<-LCproportion(List=LClist,LandCoverID=Suitable_LandCoverID) #requires LClist, provided as internal data in data/LClist.rda
#    road_netw[,list(road_netw,LCprop)]

    road_netw<- merge(road_netw,LCprop,by="ID", all=TRUE,sort=FALSE)
    road_netw[,Pe:=Pe*parameters[nparset,"scale_est"]] # parameter for scaling down probability of establishment

    #road_netw[,Pe:=LCproportion(List=LCList,LandCoverID=LandCoverID)] #for test only! Needs additional merge() to match segment ID

    ## set data.table key for road network (much faster)
    setkey(road_netw,FromNode)

    ##### start simulation ############################################

    ### select next nodes #############################

    # ## first step ####
    # nextnodes <- road_netw[FromNode%in%node_state[state>0,FromNode]] # identify next nodes
    # nextnodes <- nextnodes[node_state, nomatch=0] # get states of all nodes
    # newstate <- nextnodes$state * a0 * nextnodes$Length * nextnodes$Traffic # prob to reach nodes
    # node_state[FromNode%in%nextnodes$ToNode,state:=newstate] # assigne new values


    ## subsequent steps ######
    cat("\n Ongoing Simulation \n")

    #setup progress bar
    pb <- txtProgressBar(title = "Simulation state", label = "0% done",min=0, max=num_iter, initial=0,style = 3)

    modelList<- list()

    for (t in 1:num_iter){

      node_state_sub <- node_state[state>0,] # take a subset of occupied nodes, required to speed up 'merge' below
      nextnodes <- road_netw[FromNode%in%node_state_sub$FromNode] # identify next nodes

      nextnodes <- merge(nextnodes,node_state_sub,by="FromNode") # merge old states and next nodes

      newstate <- nextnodes[,1-prod(1-(state * Pi)),by=ToNode] # combine all probs arriving at the same node from different nodes

      node_state[.(newstate$ToNode),newarrivals:=newstate$V1] # add new state to nodes file
      node_state[,state:=1-((1-state)*(1-newarrivals))]   # combine old and new state

      road_netw<-merge(road_netw,node_state[,1:2],by="FromNode")

      #combine all probabilities to Pinv
      road_netw[!ID%in%init_segm,Pinv:=Pe*(1-Pi)*state]
      road_netw[,state_node:=state]
      road_netw[,state:=NULL]

      # store results
      if (t%in%iter_save) {modelList[[as.character(t)]]<-road_netw
      if ("state_node"%in%colnames(modelList[[as.character(t)]])==FALSE){
        stop ("no state_node column")
        }
      }
      #update progress bar
      info <- sprintf("%d%% done", round((t/num_iter)*100))
      setTxtProgressBar(pb, t/(100)*100, label=info)
    }
  }
  close(pb)

  cat("\n Model calculation completed \n")
  print(proc.time() - tmp)

  cat("\n Exporting final results \n")
  write.csv(x = road_netw,file = file.path(dir.name, "ModelResults.csv"),quote = F,row.names = F)
  # assign(x = "modelList",value = modelList,envir = .GlobalEnv)


  if (makeplot) {
    cat("\n Creating maps \n")
    plotResults(list_results=modelList,shapeObj=roads_dataset,save_dir=dir.name)
  }

  cat("\n Simulation complete \n")
  print(proc.time() - tmp)

  cat("\n Output files created in ", dir.name, "\n")

  return(modelList)
}

