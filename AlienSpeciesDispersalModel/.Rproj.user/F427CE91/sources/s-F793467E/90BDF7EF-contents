#needs matrix of parameters. should call parameters by name (via colnames(matrix)).
#  Needs parallelitazion already? If so, folder structure needed to save results of each run separately.
# parallelization not needed yet for parameters, might be useful for networks at a later stage.

SpreadModel <- function(parameters,
                        dir_data, netw_data,init_nodes, num_iter, incl_attachment=T,incl_airflow=T,
                        makeplot=F,data_plot=NULL, iter_plot=NULL){
  ####################################################################

  ### load shapefiles (takes a while!) ######################################################

  cat("\n Loading network \n")

  road_netw <- st_read(dsn=dir_data,layer=netw_data,stringsAsFactors = F)
  road_netw <- as.data.table(road_netw)
  road_netw[,Traffic:=DTVLkw+ DTVPkw]

  road_netw <- road_netw[,.(Von_Knoten,Nach_Knote,Laenge,Typ, Traffic)]
  names(road_netw) <- c("FromNode","ToNode","Length","Type","Traffic")
  road_netw[,ID:=paste(FromNode,ToNode,sep="_")]

  ## add opposite direction (only mean values in both directions are provided so far)
  # road_netw_otherdir <- road_netw
  # names(road_netw_otherdir) <- c("FromNode","ToNode","Length","Type","Traffic")
  # road_netw_otherdir[,ToNode:=road_netw[,FromNode]]
  # road_netw_otherdir[,FromNode:=road_netw[,ToNode]]
  # road_netw <- rbind(road_netw,road_netw_otherdir)

  ## transform measures into a single dispersal probability
  # Events are considered non mutually exclusive.

  #road_netw[,disp:=0]

  # if (include_traffic) {road_netw[,p_traff:=f_traff(Traffic,traf1)]
  # road_netw[,disp:=disp+p_traff]
  # }

for (nparset in nrow(parameters)){
  dir.name<-file.path(getwd(),format(Sys.time(), "%d-%b-%Y %H-%M-%S"))
  dir.create(dir.name)

  if (incl_attachment) {
    road_netw[,p_attach:=f_attach(Length,parameters[nparset,"att1"],parameters[nparset,"att2"],parameters[nparset,"att3"],p=1)]
    road_netw[,p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"pickup_prob"])]
    }
  if (incl_airflow) {
    road_netw[,p_airflow:=f_airflow(Length,parameters[nparset,"air1"],parameters[nparset,"air2"],p=1)]
    road_netw[,p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"pickup_prob"])]
  }

  col_prob<-road_netw[,.SD,.SDcols=grep("p_",colnames(road_netw))]

  road_netw[,Pi:=apply(col_prob,1,pUnion)] #prod by row


  ## set data.table key for road network (much faster)
  setkey(road_netw,FromNode)

  ##### start simulation ############################################

  ### node file #####################################
  node_state <- as.data.table(unique(c(road_netw[,unique(FromNode)],road_netw[,unique(ToNode)])))
  node_state[,state:=0]
  node_state[,newarrivals:=0]
  names(node_state) <- c("FromNode","state","newarrivals")
  node_state[,newarrivals:=as.numeric(newarrivals)]
  setkey(node_state,FromNode)

  ### initialising simulation #######################

  node_state[FromNode%in%init_nodes,state:=1]

  ### select next nodes #############################

  # ## first step ####
  # nextnodes <- road_netw[FromNode%in%node_state[state>0,FromNode]] # identify next nodes
  # nextnodes <- nextnodes[node_state, nomatch=0] # get states of all nodes
  # newstate <- nextnodes$state * a0 * nextnodes$Length * nextnodes$Traffic # prob to reach nodes
  # node_state[FromNode%in%nextnodes$ToNode,state:=newstate] # assigne new values


  ## subsequent steps ######
  cat("\n Ongoing Simulation \n")

  #setup progress bar
  pb <- txtProgressBar(title = "Simulation state", label = "0% done",min=0, max=num_iter, initial=0,style = 3)

  if (makeplot) modelList<- list()

  tmp <- proc.time()
  for (t in 1:num_iter){

    if("state" %in% colnames(road_netw)) road_netw[,state:=NULL]

    node_state_sub <- node_state[state>0,] # take a subset of occupied nodes, required to speed up 'merge' below
    nextnodes <- road_netw[FromNode%in%node_state_sub$FromNode] # identify next nodes

    nextnodes <- merge(nextnodes,node_state_sub,by="FromNode") # merge old states and next nodes

    newstate <- nextnodes[,1-prod(1-(state * Pi)),by=ToNode] # combine all probs arriving at the same node from different nodes

    node_state[.(newstate$ToNode),newarrivals:=newstate$V1] # add new state to nodes file
    node_state[,state:=1-((1-state)*(1-newarrivals))]   # combine old and new state

    road_netw<-merge(road_netw,node_state[,1:2],by="FromNode") # crashes after 1st iteration, multiple state column

    #get PE for segment
    road_netw[,Pe:=1] #for test only!

    #combine to Pinv
    road_netw[,Pinv:=Pe*(1-Pi)*state]

    # update plot list
    if (makeplot){
      if (t%in%iter_plot) modelList[[as.character(t)]]<-road_netw
    }

    #update progress bar
    info <- sprintf("%d%% done", round((t/num_iter)*100))
    setTxtProgressBar(pb, t/(100)*100, label=info)
    }
  }
  close(pb)

  cat("\n Exporting final results \n")
  write.csv(x = road_netw,file = file.path(dir.name, "ModelResults.csv"),quote = F,row.names = F)
 # assign(x = "modelList",value = modelList,envir = .GlobalEnv)

  cat("\n Creating maps \n")
  if (makeplot) plotResults(list_results=modelList,dir_data=dir_data,netw_data=netw_data,data_plot=data_plot,save_dir=dir.name)

  cat("\n Simulation complete \n")
  cat("\n Output files created in ", dir.name, "\n")
  print(proc.time() - tmp)
return(modelList)
}

