setkey(road_netw,FromNode)
road_netw<-merge(road_netw,Container_netw,by="FromNode",all.x=T) # adding container state of FromNo
road_netw[,stateFromNode:=Pi_container]
set(Container_netw, j=which(colnames(Container_netw) %in% c("Pi_container")), value=NULL )
names(Container_netw)[1]<-c("ToNode")
setkey(Container_netw,ToNode)
setkey(road_netw,ToNode)
road_netw<-merge(road_netw,Container_netw,by="ToNode",all.x=T) # adding container state of ToNode
road_netw[,stateToNode:=Pi_container]
#Filling NAs (some nodes are only from_nodes ot to_nodes, or are not in the Cargo Areas)
road_netw[is.na(stateFromNode),stateFromNode:=0]
road_netw[is.na(stateToNode),stateToNode:=0]
setkey(road_netw,FromNode)
} else {
road_netw[,Pi_container:=0]
}
#Assigning initial state=1 to initially invaded nodes.
# MUST BE DONE AFTER CALLING CONTAINER FUNCTION, this state must take precedence.
init_nodes <- road_netw[ID%in%init_segm,c(FromNode,ToNode)] # new
road_netw[FromNode%in%init_nodes,stateFromNode:=1]
road_netw[ToNode%in%init_nodes,stateToNode:=1]
#get Traffic PI for network segment
cat("\n Calculating Probability of Introduction for each segment \n")
if (incl_natural){
road_netw[,p_natural:=f_natural(Length,parameters[nparset,"nat1"],parameters[nparset,"nat2"] )]
}
if (incl_attachment) {
road_netw[,p_attach:=f_attach(Length,parameters[nparset,"att1"],parameters[nparset,"att2"],parameters[nparset,"att3"])]
road_netw[grep("S",road_netw$ID),p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"S_att0"])]
road_netw[grep("R",road_netw$ID),p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"R_att0"])]
}
if (incl_airflow) {
road_netw[,p_airflow:=f_airflow(Length,parameters[nparset,"air1"],parameters[nparset,"air2"])]
road_netw[grep("S",road_netw$ID),p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"S_air0"])] # new
road_netw[grep("R",road_netw$ID),p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"R_air0"])]
}
road_netw[, Pi:=1-Reduce("*", 1-.SD), .SDcols=grep("p_",colnames(road_netw))] # new solution
# col_prob<-road_netw[,.SD,.SDcols=grep("p_",colnames(road_netw))] # see above new solution
#
# road_netw[,Pi:=apply(col_prob,1,pUnion)] #prod by row
if(incl_pallets==TRUE){
cat("\n Calculating Probability of Introduction for each Cargo area \n")
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
}
#get PE for segment
cat("\n Calculating Probability of Establishment for each segment \n")
# new    # LCprop<-LCproportion(IDs=unique(road_netw$ID),List=LClist,LandCoverID=LandCoverID) #requires LClist, provided as internal data in data/LClist.rda
#    road_netw[,list(road_netw,LCprop)]
# new    if (restart==TRUE){road_netw[,Pe:=NULL]}
# new    road_netw<- merge(road_netw,LCprop,by="ID", all=TRUE,sort=FALSE)
#road_netw[,Pe:=1-exp(-parameters[nparset,"est0"]*LCsuit)] # parameter for scaling down probability of establishment # new
road_netw[,Pe:=parameters[nparset,"est0"]*LCsuit] # parameter for scaling down probability of establishment # new
#road_netw[,Pe:=LCproportion(List=LCList,LandCoverID=LandCoverID)] #for test only! Needs additional merge() to match segment ID
## set data.table key for road network (much faster)
# And subset relevant information
road_netw_details <- road_netw[,c("ID","LCsuit","Length","Traffic","p_natural","p_attach","p_airflow","Order")]
set( road_netw, j=which(colnames(road_netw) %in% c("LCsuit","Length","Traffic","p_natural","p_attach","p_airflow","Order")), value=NULL ) # new
setkey(road_netw,FromNode)
##### start simulation ############################################
### select next nodes #############################
# ## first step ####
# nextnodes <- road_netw[FromNode%in%node_state[state>0,FromNode]] # identify next nodes
# nextnodes <- nextnodes[node_state, nomatch=0] # get states of all nodes
# newstate <- nextnodes$state * a0 * nextnodes$Length * nextnodes$Traffic # prob to reach nodes
# node_state[FromNode%in%nextnodes$ToNode,state:=newstate] # assigne new values
modelList<- list()
t
#commodities part (pallets only)
if (incl_pallets==TRUE){
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:= 1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromAreas states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromAreas
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
###Assign pallet probability (state of node) to each nodes in each area, and update traffic network here:
PalletCols<-colnames(Pallets_netw)%in%c("ToArea","stateToArea")
PalletsToNetw<-Pallets_netw[, ..PalletCols] # new
# get ToNodes in ToAreas
setnames(PalletsToNetw,c("AreaPallet","stateToArea"))
PalletsToNetw<-as.data.table(aggregate(stateToArea ~ AreaPallet, PalletsToNetw, pUnion))
PalletsToNetw<-merge(Nodes_CargoCell,PalletsToNetw,by="AreaPallet",all.x=T)
PalletsToNetw[is.na(stateToArea),stateToArea:=0] # fill in NA's
# add column in road_netw wit stateToArea associated to proper ToNode
PalletCols<-colnames(PalletsToNetw)%in%c("NodeID","stateToArea")
PalletsToNetw<-PalletsToNetw[, ..PalletCols]
setnames(PalletsToNetw,c("ToNode","stateToArea"))
setkey(PalletsToNetw,ToNode)
setkey(road_netw,ToNode)
road_netw<-merge(road_netw,PalletsToNetw,by="ToNode",all.x=T)
setkey(road_netw,FromNode)
} else {
road_netw[,stateToArea:=0]
}
#    assign(x = "road_netw",value = road_netw,envir = .GlobalEnv)
###### network part
ind <- which(road_netw$stateFromNode>0 & road_netw$stateToNode<1) # select links with non-empty start node and non-filled end node
road_netw[ind,newarrivals:=   1-prod(1-(stateFromNode * Pi )) ,by=ToNode] # calculate pintro for each link
road_netw[ind,stateToNode:=1-(prod((1-stateToNode) * (1-newarrivals) * (1-Pi_container) * (1-stateToArea))),by=ToNode] # update ToNodes with old and new state
road_netw[,stateToNode:=1-(prod((1-stateToNode))),by=ToNode] # update ToNodes with old and new state
newstate <- unique(road_netw[ind,c("ToNode","stateToNode")],by="ToNode") # extract new state of ToNodes to update FromNodes states
setnames(newstate,c("FromNode","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromNode)
setkey(road_netw,FromNode)
road_netw <- merge(road_netw,newstate,by="FromNode",all.x=T)
# road_netw <- newstate[road_netw] # merge road_netw and newstate to update FromNodes states
road_netw[newstate>0 ,stateFromNode:=newstate] # assigne new states to FromNodes
road_netw[,newstate:=NULL] # remove column to avoid columns with the same names
road_netw[,stateToNode_Area:=stateToArea]
road_netw[,stateToArea:=NULL]
#  node_state_sub <- node_state[state>0,] # take a subset of occupied nodes, required to speed up 'merge' below
#
#  nextnodes <- road_netw[FromNode%in%node_state_sub$FromNode] # identify next nodes
#
# nextnodes <- merge(nextnodes,node_state_sub,by="FromNode") # merge old states and next nodes
#
# newstate <- nextnodes[,1-prod(1-(state * Pi)),by=ToNode] # combine all probs arriving at the same node from different nodes
#
# node_state[.(newstate$ToNode),newarrivals:=newstate$V1] # add new state to nodes file
# node_state[,state:=1-((1-state)*(1-newarrivals))]   # combine old and new state
#
# road_netw<-merge(road_netw,node_state[,1:2],by="FromNode")
#
# #combine all probabilities to Pinv
# iters<-as.numeric(names(init_segm))
# road_netw[!ID%in%as.character(unlist(init_segm[c(which(iters<t))])),Pinv:=Pe*(1-Pi)*state]
# road_netw[,state_node:=state]
# road_netw[,state:=NULL]
road_netw[,p_link:=stateToNode] #calculate probability of link invasion: to be involved in Pinv instead of Pi, or it stays constant in time
road_netw[,Pinv:=Pe*p_link] # calculate total probability for links
road_netw[ID%in%init_segm,Pinv:=1] # assigning Pinv=1 for initial links. No effect on Traffic spread dynamics (use nodes).
setkey(road_netw,ID)
setkey(road_netw_details,ID)
road_netw_out <- road_netw_details[road_netw]
setkey(road_netw_out,Order)
modelList[[as.character(t)]]<-road_netw_out
PalletsToNetw[is.na(stateToArea),]
Pallets_netw[is.na(Pi_pallet),]
Pallets_netw[is.na(stateToArea),]
t<-2
#commodities part (pallets only)
if (incl_pallets==TRUE){
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:= 1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromAreas states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromAreas
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
###Assign pallet probability (state of node) to each nodes in each area, and update traffic network here:
PalletCols<-colnames(Pallets_netw)%in%c("ToArea","stateToArea")
PalletsToNetw<-Pallets_netw[, ..PalletCols] # new
# get ToNodes in ToAreas
setnames(PalletsToNetw,c("AreaPallet","stateToArea"))
PalletsToNetw<-as.data.table(aggregate(stateToArea ~ AreaPallet, PalletsToNetw, pUnion))
PalletsToNetw<-merge(Nodes_CargoCell,PalletsToNetw,by="AreaPallet",all.x=T)
PalletsToNetw[is.na(stateToArea),stateToArea:=0] # fill in NA's
# add column in road_netw wit stateToArea associated to proper ToNode
PalletCols<-colnames(PalletsToNetw)%in%c("NodeID","stateToArea")
PalletsToNetw<-PalletsToNetw[, ..PalletCols]
setnames(PalletsToNetw,c("ToNode","stateToArea"))
setkey(PalletsToNetw,ToNode)
setkey(road_netw,ToNode)
road_netw<-merge(road_netw,PalletsToNetw,by="ToNode",all.x=T)
setkey(road_netw,FromNode)
} else {
road_netw[,stateToArea:=0]
}
road_netw[is.na(newarrivals),]
road_netw[is.na(Pi_container),]
road_netw[is.na(stateToNode),]
road_netw[is.na(stateToNode_Area),]
road_netw[is.na(stateToArea),]
###### network part
ind <- which(road_netw$stateFromNode>0 & road_netw$stateToNode<1) # select links with non-empty start node and non-filled end node
road_netw[ind,newarrivals:=   1-prod(1-(stateFromNode * Pi )) ,by=ToNode] # calculate pintro for each link
road_netw[is.na(newarrivals),]
road_netw[ind,stateToNode:=1-(prod((1-stateToNode) * (1-newarrivals) * (1-Pi_container) * (1-stateToArea))),by=ToNode] # update ToNodes with old and new state
road_netw[is.na(newarrivals),]
road_netw[is.na(stateToNode),]
road_netw[is.na(Pi_container),]
road_netw[is.na(Pi),]
road_netw[is.na(stateToArea),]
###### network part
ind <- which(road_netw$stateFromNode>0 & road_netw$stateToNode<1) # select links with non-empty start node and non-filled end node
road_netw[ind,newarrivals:=   1-prod(1-(stateFromNode * Pi )) ,by=ToNode] # calculate pintro for each link
road_netw[ind,stateToNode:=1-(prod((1-stateToNode) * (1-newarrivals) * (1-Pi_container) * (1-stateToArea))),by=ToNode] # update ToNodes with old and new state
write.table(x = road_netw[is.na(stateToNode),file="road_new.txt",quote=FALSE,row.names=FALSE,sep=""\t)
write.table(x = road_netw[is.na(stateToNode),file="road_new.txt",quote=FALSE,row.names=FALSE,sep="\t")
write.table(x = road_netw[is.na(stateToNode)],file="road_new.txt",quote=FALSE,row.names=FALSE,sep="\t")
getwd()
results<-runCASPIAN("~/../Desktop/configFile.R"))
results<-runCASPIAN("~/../Desktop/configFile.R")
results[[1]][(is.na(p_link)),]
results[[2]][(is.na(p_link)),]
plotResults(results,shapeObj = Road_Railway_Network,save_plot = FALSE)
results[[2]][(is.na(Pinv)),]
results[[1]][(is.na(Pinv)),]
summary(results[[1]])
summary(results[[2]])
summary(PalletsFlow$numPallets)
hist(PalletsFlow$numPallets)
results[[1]][(is.na(Pinv)),Length]
results[[1]][(is.na(p_link)),Length]
results[[1]][(is.na(p_link)),Length][1]
results<-runCASPIAN("~/../Desktop/configFile.R"))
results<-runCASPIAN("~/../Desktop/configFile.R")
rm(list=ls())
results<-runCASPIAN("~/../Desktop/configFile.R")
library(CASPIAN)
results<-runCASPIAN("~/../Desktop/configFile.R")
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
roads_shp<-Road_Railway_Network
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
netw_type <- c("Rail","A","B") # types of network considered : "Rail" "A"    "B"    "L"    "S"    "K"    "F"    "G"    "X"    "R"    "k"
colnames(roads_shp@data) <- c("FromNode","ToNode","Type","Length","cargo","passengers", "ID")
if (all(netw_type!=c("all"))) roads_shp<-roads_shp[roads_shp@data$Type%in%netw_type,]
road_netw <- as.data.table(roads_shp@data)
road_netw[,Order:=c(1:nrow(roads_shp@data))]
suppressWarnings(
if (all(traffic_type!=c("all"))) {
colTraffic<-which(colnames(road_netw)%in%traffic_type)
road_netw[,Traffic:=rowSums(road_netw[, ..colTraffic])]} else {
road_netw[,Traffic:=rowSums(cbind(cargo,passengers))]}
)
road_netw[,Traffic:=round((Traffic)*365/12,0)]
set(road_netw, j=which(colnames(road_netw) %in% c("cargo","passengers")), value=NULL )
#road_netw <- road_netw[,.(Von_Knoten,Nach_Knote,Laenge,Typ, Traffic,ID)]
cat("\n Initializing node states \n")
road_netw[,newarrivals:=0]
road_netw[,newarrivals:=as.numeric(newarrivals)]
road_netw[,stateFromNode:=0]
road_netw[,stateToNode:=0]
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
setnames(Nodes_CargoCell,c(names(Nodes_CargoCell)[1:2],"NodeID"))
summary(Nodes_CargoCell)
netw_type <- c("all") # types of network considered : "Rail" "A"    "B"    "L"    "S"    "K"    "F"    "G"    "X"    "R"    "k"
colnames(roads_shp@data) <- c("FromNode","ToNode","Type","Length","cargo","passengers", "ID")
if (all(netw_type!=c("all"))) roads_shp<-roads_shp[roads_shp@data$Type%in%netw_type,]
road_netw <- as.data.table(roads_shp@data)
road_netw[,Order:=c(1:nrow(roads_shp@data))]
suppressWarnings(
if (all(traffic_type!=c("all"))) {
colTraffic<-which(colnames(road_netw)%in%traffic_type)
road_netw[,Traffic:=rowSums(road_netw[, ..colTraffic])]} else {
road_netw[,Traffic:=rowSums(cbind(cargo,passengers))]}
)
road_netw[,Traffic:=round((Traffic)*365/12,0)]
set(road_netw, j=which(colnames(road_netw) %in% c("cargo","passengers")), value=NULL )
#road_netw <- road_netw[,.(Von_Knoten,Nach_Knote,Laenge,Typ, Traffic,ID)]
cat("\n Initializing node states \n")
road_netw[,newarrivals:=0]
road_netw[,newarrivals:=as.numeric(newarrivals)]
road_netw[,stateFromNode:=0]
road_netw[,stateToNode:=0]
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
setnames(Nodes_CargoCell,c(names(Nodes_CargoCell)[1:2],"NodeID"))
summary(Nodes_CargoCell)
CargoAreas<-Cargo_shp
roads_shp<-Road_Railway_Network
unique(roads_shp$FromNode)
length(unique(roads_shp$FromNode))
netw_type
netw_type <- c("Rail","A","B") # types of network considered : "Rail" "A"    "B"    "L"    "S"    "K"    "F"    "G"    "X"    "R"    "k"
colnames(roads_shp@data) <- c("FromNode","ToNode","Type","Length","cargo","passengers", "ID")
if (all(netw_type!=c("all"))) roads_shp<-roads_shp[roads_shp@data$Type%in%netw_type,]
length(unique(roads_shp$FromNode))
road_netw <- as.data.table(roads_shp@data)
road_netw[,Order:=c(1:nrow(roads_shp@data))]
suppressWarnings(
if (all(traffic_type!=c("all"))) {
colTraffic<-which(colnames(road_netw)%in%traffic_type)
road_netw[,Traffic:=rowSums(road_netw[, ..colTraffic])]} else {
road_netw[,Traffic:=rowSums(cbind(cargo,passengers))]}
)
road_netw[,Traffic:=round((Traffic)*365/12,0)]
set(road_netw, j=which(colnames(road_netw) %in% c("cargo","passengers")), value=NULL )
road_netw[,newarrivals:=0]
road_netw[,newarrivals:=as.numeric(newarrivals)]
road_netw[,stateFromNode:=0]
road_netw[,stateToNode:=0]
NodesCoords<-getNodesCoord(roads_shp)
NodesCoords
nrow(NodesCoords)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
nrow(Nodes_CargoCell)
netw_type <- c("all") # types of network considered : "Rail" "A"    "B"    "L"    "S"    "K"    "F"    "G"    "X"    "R"    "k"
roads_shp<-Road_Railway_Network
colnames(roads_shp@data) <- c("FromNode","ToNode","Type","Length","cargo","passengers", "ID")
if (all(netw_type!=c("all"))) roads_shp<-roads_shp[roads_shp@data$Type%in%netw_type,]
road_netw <- as.data.table(roads_shp@data)
road_netw[,Order:=c(1:nrow(roads_shp@data))]
suppressWarnings(
if (all(traffic_type!=c("all"))) {
colTraffic<-which(colnames(road_netw)%in%traffic_type)
road_netw[,Traffic:=rowSums(road_netw[, ..colTraffic])]} else {
road_netw[,Traffic:=rowSums(cbind(cargo,passengers))]}
)
road_netw[,Traffic:=round((Traffic)*365/12,0)]
set(road_netw, j=which(colnames(road_netw) %in% c("cargo","passengers")), value=NULL )
#road_netw <- road_netw[,.(Von_Knoten,Nach_Knote,Laenge,Typ, Traffic,ID)]
cat("\n Initializing node states \n")
road_netw[,newarrivals:=0]
road_netw[,newarrivals:=as.numeric(newarrivals)]
road_netw[,stateFromNode:=0]
road_netw[,stateToNode:=0]
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
nrow(NodesCoords)
nrow(Nodes_CargoCell)
nrow(roads_shp@data)
length(unique(roads_shp@data$FromNode))
length(unique(roads_shp@data$ToNode))
netw_type <- c("Rail","A","B") # types of network considered : "Rail" "A"    "B"    "L"    "S"    "K"    "F"    "G"    "X"    "R"    "k"
roads_shp<-Road_Railway_Network
#roads_shp@data$ID<-paste(roads_shp@data$Von_Knoten,roads_shp@data$Nach_Knote,sep="_")
#roads_shp@data[, c(4,6,7)]<-sapply(roads_shp@data[, c(4,6,7)], as.numeric)
colnames(roads_shp@data) <- c("FromNode","ToNode","Type","Length","cargo","passengers", "ID")
if (all(netw_type!=c("all"))) roads_shp<-roads_shp[roads_shp@data$Type%in%netw_type,]
road_netw <- as.data.table(roads_shp@data)
road_netw[,Order:=c(1:nrow(roads_shp@data))]
suppressWarnings(
if (all(traffic_type!=c("all"))) {
colTraffic<-which(colnames(road_netw)%in%traffic_type)
road_netw[,Traffic:=rowSums(road_netw[, ..colTraffic])]} else {
road_netw[,Traffic:=rowSums(cbind(cargo,passengers))]}
)
road_netw[,Traffic:=round((Traffic)*365/12,0)]
set(road_netw, j=which(colnames(road_netw) %in% c("cargo","passengers")), value=NULL )
#road_netw <- road_netw[,.(Von_Knoten,Nach_Knote,Laenge,Typ, Traffic,ID)]
cat("\n Initializing node states \n")
road_netw[,newarrivals:=0]
road_netw[,newarrivals:=as.numeric(newarrivals)]
road_netw[,stateFromNode:=0]
road_netw[,stateToNode:=0]
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
setnames(Nodes_CargoCell,c(names(Nodes_CargoCell)[1:2],"NodeID"))
length(unique(CargoAreas$AreaContainer))
length(unique(Nodes_CargoCell$AreaContainer))
length(unique(CargoAreas$AreaPallet))
length(unique(Nodes_CargoCell$AreaPallet))
length(unique(Nodes_CargoCell[is.na(AreaPallet),AreaPallet]))
length(unique(Nodes_CargoCell[is.na(AreaPallet)==FALSE,AreaPallet]))
length(unique(CargoAreas[is.na(AreaPallet)==FALSE,AreaPallet]))
length(unique(CargoAreas$AreaPallet[is.na(CargoAreas$AreaPallet)==FALSE]))
#load pallet flow
Pallets_netw<-as.data.table(PalletsFlow)#need to update to provide external file here. Perhaps also in network file?
Pallets_netw
nrow(Pallets_netw)
nrow(Pallets_netw[ToArea%in%Nodes_CargoCell$AreaPallet,])
x11()
plot(border_dataset)
plot(Cargo_shp,border="lightgray",add=T)
plot(roads_shp,col="red",add=T)
plot(Cargo_shp,border="lightgray",add=T)
plot(border_dataset,add=T)
summary(PalletsFlow$numPallets)
x<-1:310000
plot(f_container(x))
plot(f_container(x),10)
plot(f_container(x,10))
plot(f_container(x,100))
plot(f_container(x,10000))
plot(f_container(x,100000))
Container_netw<-as.data.table(ContainerFlow) #need to update to provide external file here. Perhaps also in network file?
Container_netw<-Container_netw[FromArea!=ToArea,] #remove traffic from/to same area
Container_netw<-Container_netw[ToArea%in%Nodes_CargoCell$AreaContainer,] #subset, keep only areas where there are traffic nodes of the chosen netw_type
Container_netw[,numContainers:=numContainers/12] #monthly scale
Container_netw<-as.data.table(aggregate(numContainers ~ ToArea, Container_netw, sum))
Container_netw
x<-Container_netw$numContainers
plot(f_container(x,1000))
setkey(Container_netw,numContainers)
plot(f_container(x,1000))
plot(f_container(x,100))
plot(f_container(x,10))
plot(f_container(x,1))
Pallets_Total<-as.data.table(aggregate(numPallet ~ AreaPallet, Pallet_netw, sum))
Pallets_Total<-as.data.table(aggregate(numPallet ~ AreaPallet, Pallets_netw, sum))
Pallets_netw
Pallets_Total<-as.data.table(aggregate(numPallets ~ AreaPallet, Pallets_netw, sum))
Pallets_Total<-as.data.table(aggregate(numPallets ~ ToArea, Pallets_netw, sum))
x<-Pallets_Total$numPallets
plot(f_container(x,1))
plot(f_container(x,100000))
setkey(Pallets_Total,numPallets)
plot(f_container(x,100000))
x<-Pallets_Total$numPallets
plot(f_container(x,100000))
plot(f_container(x,10000))
summary(Pallets_netw$numPallets)
summary(Pallets_total$numPallets)
summary(Pallets_Total$numPallets)
plot(f_container(x,10000)~x)
plot(f_container(x,100000)~x)
plot(f_container(x,1000000)~x)
plot(f_container(x,1)~x)
plot(f_container(x,10)~x)
plot(f_container(x,10^12)~x)
plot(f_container(x,10^10)~x)
plot(f_container(x,10^8)~x)
plot(f_container(x,10^7)~x)
plot(f_container(x,10^6)~x)
x<-Container_netw$numContainers
plot(f_container(x,10^6)~x)
plot(f_container(x,10^4)~x)
plot(f_container(x,10^5)~x)
plot(f_container(x,10^6)~x)
Pall_treshold<-5000
nrow(Pallets_netw)
#load pallet flow
Pallets_netw<-as.data.table(PalletsFlow)#need to update to provide external file here. Perhaps also in network file?
nrow(Pallets_netw)
Pallets_netw<-Pallets_netw[FromArea!=ToArea,] #remove traffic from/to same area
nrow(Pallets_netw)
Pallets_netw<-Pallets_netw[ToArea%in%Nodes_CargoCell$AreaPallet,] #subset, keep only areas where there are traffic nodes of the chosen netw_type
nrow(Pallets_netw)
Pall_treshold
# remove links with number of exchanged pallets per year < than Pall_treshold:
if (Pall_treshold>0) { Pallets_netw<-Pallets_netw[,numPallets>=Pall_treshold]}
nrow(Pallets_netw)
Pallets_netw<-as.data.table(PalletsFlow)#need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,] #remove traffic from/to same area
Pallets_netw<-Pallets_netw[ToArea%in%Nodes_CargoCell$AreaPallet,] #subset, keep only areas where there are traffic nodes of the chosen netw_type
Pall_treshold<-50
# remove links with number of exchanged pallets per year < than Pall_treshold:
if (Pall_treshold>0) { Pallets_netw<-Pallets_netw[,numPallets>=Pall_treshold]}
nrow(Pallets_netw)
Pallets_netw<-as.data.table(PalletsFlow)#need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,] #remove traffic from/to same area
Pallets_netw<-Pallets_netw[ToArea%in%Nodes_CargoCell$AreaPallet,] #subset, keep only areas where there are traffic nodes of the chosen netw_type
Pallets_netw[,numPallets>=Pall_treshold]
Pallets_netw<-Pallets_netw[,numPallets>=Pall_treshold]
Pallets_netw
Pallets_netw<-as.data.table(PalletsFlow)#need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,] #remove traffic from/to same area
Pallets_netw<-Pallets_netw[ToArea%in%Nodes_CargoCell$AreaPallet,] #subset, keep only areas where there are traffic nodes of the chosen netw_type
# remove links with number of exchanged pallets per year < than Pall_treshold:
if (Pall_treshold>0) { Pallets_netw<-Pallets_netw[numPallets>=Pall_treshold,]}
nrow(Pallets_netw)
x<-Container_netw$numContainers
summary(x)
length(x)
length(x[x>10])
length(x[x>5])
x<-(PalletsFlow$numPallets)
summary(x)
#Treshold for pallets volume: all links with number of containers exchanged per year lower than Pall_treshold will not be considered
Pall_treshold<-5
length(x)
length(x[x>5])
length(x[x>10])
length(x[x>20])
length(x[x>50])
length(x[x>100])
length(x[x>300])
results<-runCASPIAN("~/../Desktop/configFile.R")
results<-runCASPIAN("~/../Desktop/configFile.R")
results<-runCASPIAN("~/../Desktop/configFile.R")
results<-runCASPIAN(file.path(system.file("extdata", package="CASPIAN"),"configFile.R"))
results<-runCASPIAN(file.path(system.file("extdata", package="CASPIAN"),"configFile.R"))
summary(results[[3]]$p_link-results[[2]]$p_link)
summary(results[[3]]$Pinv-results[[2]]$Pinv)
summary(results[[3]]$Pinv[results[[2]]$Pinv>0]-results[[2]]$Pinv[results[[2]]$Pinv>0])
hist(results[[3]]$Pinv[results[[2]]$Pinv>0]-results[[2]]$Pinv[results[[2]]$Pinv>0])
hist(results[[3]]$Pinv[results[[2]]$Pinv>0]-results[[2]]$Pinv[results[[2]]$Pinv>0],nclass=100)
hist(results[[3]]$p_link[results[[2]]$p_link>0]-results[[2]]$p_link[results[[2]]$p_link>0],nclass=100)
library(CASPIAN)
