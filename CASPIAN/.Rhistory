road_netw_cont
dir.name<-file.path(getwd(),paste0("CASPIAN_",format(Sys.time(), "%d-%b-%Y %H-%M-%S")))
dir.create(dir.name)
if (restart==TRUE){ cat("\n Loading previous results \n")
load(file_restart)
init_data<-restart_data
} else if (restart==FALSE & initialize==TRUE) {
init_data<-InitializeSpread(internal_dataset=internal_dataset,init_coords=init_coords,max_dist=max_dist,
netw_type=netw_type,save_init=save_init, save_dir=dir.name,file_init=file_init,
species_preferences=species_preferences,traffic_type=traffic_type,
incl_containers=incl_containers,incl_pallets=incl_pallets)
} else if (restart==FALSE & initialize==FALSE) {cat("\n Loading initialization data \n")
load(file_init)
}
roads_shp<-init_data$roads_shp
road_netw<-roads_shp@data
init_segm<-init_data$init_segm
if (incl_pallets==TRUE | incl_containers==TRUE){
Nodes_CargoCell<-init_data$Nodes_CargoCell
}
if (incl_containers==TRUE){
Container_netw<-init_data$Container_netw
}
if (incl_pallets==TRUE){
Pallets_netw<-init_data$Pallets_netw
init_Areas<-init_data$init_Areas
}
nparset
road_netw[,Pi_container:=0]
if (incl_containers==TRUE){
road_netw <- ContainerNodeState(ContainerObj=Container_netw,Cont_parameter=parameters[nparset,"cont1"],
Nodes_CargoCell=Nodes_CargoCell,netwObj=road_netw)
}
road_netw_cont<-netwObj
ContainerObj<-Container_netw
#Calculating nodes probability:
ContainerObj[,Pi_container:=f_container(numContainers,Cont_parameter)]
dir.name<-file.path(getwd(),paste0("CASPIAN_",format(Sys.time(), "%d-%b-%Y %H-%M-%S")))
dir.create(dir.name)
if (restart==TRUE){ cat("\n Loading previous results \n")
load(file_restart)
init_data<-restart_data
} else if (restart==FALSE & initialize==TRUE) {
init_data<-InitializeSpread(internal_dataset=internal_dataset,init_coords=init_coords,max_dist=max_dist,
netw_type=netw_type,save_init=save_init, save_dir=dir.name,file_init=file_init,
species_preferences=species_preferences,traffic_type=traffic_type,
incl_containers=incl_containers,incl_pallets=incl_pallets)
} else if (restart==FALSE & initialize==FALSE) {cat("\n Loading initialization data \n")
load(file_init)
}
roads_shp<-init_data$roads_shp
road_netw<-roads_shp@data
init_segm<-init_data$init_segm
if (incl_pallets==TRUE | incl_containers==TRUE){
Nodes_CargoCell<-init_data$Nodes_CargoCell
}
if (incl_containers==TRUE){
Container_netw<-init_data$Container_netw
}
if (incl_pallets==TRUE){
Pallets_netw<-init_data$Pallets_netw
init_Areas<-init_data$init_Areas
}
#Call Containers here
road_netw[,Pi_container:=0]
ContainerObj<-Container_netw
Cont_parameter<-parameters[nparset,"cont1"]
netwObj<-road_netw
road_netw_cont<-netwObj
#Calculating nodes probability:
ContainerObj[,Pi_container:=f_container(numContainers,Cont_parameter)]
set(ContainerObj, j=which(colnames(ContainerObj) %in% c("numContainers")), value=NULL )
#Associate container probabilities to nodes
setkey(ContainerObj,FromNode)
setkey(road_netw_cont,FromNode)
road_netw_cont<-merge(road_netw_cont,ContainerObj,by="FromNode",all.x=T) # adding container state of FromNo
road_netw_cont
road_netw
dir.name<-file.path(getwd(),paste0("CASPIAN_",format(Sys.time(), "%d-%b-%Y %H-%M-%S")))
dir.create(dir.name)
if (restart==TRUE){ cat("\n Loading previous results \n")
load(file_restart)
init_data<-restart_data
} else if (restart==FALSE & initialize==TRUE) {
init_data<-InitializeSpread(internal_dataset=internal_dataset,init_coords=init_coords,max_dist=max_dist,
netw_type=netw_type,save_init=save_init, save_dir=dir.name,file_init=file_init,
species_preferences=species_preferences,traffic_type=traffic_type,
incl_containers=incl_containers,incl_pallets=incl_pallets)
} else if (restart==FALSE & initialize==FALSE) {cat("\n Loading initialization data \n")
load(file_init)
}
roads_shp<-init_data$roads_shp
road_netw<-roads_shp@data
init_segm<-init_data$init_segm
if (incl_pallets==TRUE | incl_containers==TRUE){
Nodes_CargoCell<-init_data$Nodes_CargoCell
}
if (incl_containers==TRUE){
Container_netw<-init_data$Container_netw
}
if (incl_pallets==TRUE){
Pallets_netw<-init_data$Pallets_netw
init_Areas<-init_data$init_Areas
}
if (incl_containers==TRUE){
road_netw <- ContainerNodeState(ContainerObj=Container_netw,Cont_parameter=parameters[nparset,"cont1"],
Nodes_CargoCell=Nodes_CargoCell,netwObj=road_netw)
} else {road_netw[,Pi_container:=0]}
Container_netw
init_data$Container_netw
if (restart==TRUE){ cat("\n Loading previous results \n")
load(file_restart)
init_data<-restart_data
} else if (restart==FALSE & initialize==TRUE) {
init_data<-InitializeSpread(internal_dataset=internal_dataset,init_coords=init_coords,max_dist=max_dist,
netw_type=netw_type,save_init=save_init, save_dir=dir.name,file_init=file_init,
species_preferences=species_preferences,traffic_type=traffic_type,
incl_containers=incl_containers,incl_pallets=incl_pallets)
} else if (restart==FALSE & initialize==FALSE) {cat("\n Loading initialization data \n")
load(file_init)
}
roads_shp<-init_data$roads_shp
road_netw<-roads_shp@data
init_segm<-init_data$init_segm
if (incl_pallets==TRUE | incl_containers==TRUE){
Nodes_CargoCell<-init_data$Nodes_CargoCell
}
if (incl_containers==TRUE){
Container_netw<-init_data$Container_netw
}
if (incl_pallets==TRUE){
Pallets_netw<-init_data$Pallets_netw
init_Areas<-init_data$init_Areas
}
# node_state<-init_data$node_state
## add opposite direction (only mean values in both directions are provided so far)
# road_netw_otherdir <- road_netw
# names(road_netw_otherdir) <- c("FromNode","ToNode","Length","Type","Traffic")
# road_netw_otherdir[,ToNode:=road_netw[,FromNode]]
# road_netw_otherdir[,FromNode:=road_netw[,ToNode]]
# road_netw <- rbind(road_netw,road_netw_otherdir)
## transform measures into a single dispersal probability
# Events are considered non mutually exclusive.
#road_netw[,disp:=0]
# if (include_traffic) {road_netw[,p_traff:=f_traff(Traffic,traf1)]
# road_netw[,disp:=disp+p_traff]
# }
if (incl_containers==TRUE){
Container_netw[,Pi_container:=f_container(numContainers,Cont_parameter)]
set(Container_netw, j=which(colnames(Container_netw) %in% c("numContainers")), value=NULL )
#Associate container probabilities to nodes
setkey(Container_netw,FromNode)
setkey(road_netw,FromNode)
road_netw<-merge(road_netw,Container_netw,by="FromNode",all.x=T) # adding container state of FromNo
road_netw[,stateFromNode:=Pi_container]
names(Container_netw)[1]<-c("ToNode")
setkey(Container_netw,ToNode)
setkey(road_netw,ToNode)
road_netw<-merge(road_netw,Container_netw,by="ToNode",all.x=T) # adding container state of ToNode
road_netw[,stateToNode:=Pi_container]
#Filling NAs (some nodes are only from_nodes ot to_nodes, or are not in the Cargo Areas)
road_netw[is.na(stateFromNode),stateFromNode:=0]
road_netw[is.na(stateToNode),stateToNode:=0]
} else {
road_netw[,Pi_container:=0]
}
road_netw
init_data$Container_netw
dir.name<-file.path(getwd(),paste0("CASPIAN_",format(Sys.time(), "%d-%b-%Y %H-%M-%S")))
dir.create(dir.name)
if (restart==TRUE){ cat("\n Loading previous results \n")
load(file_restart)
init_data<-restart_data
} else if (restart==FALSE & initialize==TRUE) {
init_data<-InitializeSpread(internal_dataset=internal_dataset,init_coords=init_coords,max_dist=max_dist,
netw_type=netw_type,save_init=save_init, save_dir=dir.name,file_init=file_init,
species_preferences=species_preferences,traffic_type=traffic_type,
incl_containers=incl_containers,incl_pallets=incl_pallets)
} else if (restart==FALSE & initialize==FALSE) {cat("\n Loading initialization data \n")
load(file_init)
}
roads_shp<-init_data$roads_shp
road_netw<-roads_shp@data
init_segm<-init_data$init_segm
if (incl_pallets==TRUE | incl_containers==TRUE){
Nodes_CargoCell<-init_data$Nodes_CargoCell
}
if (incl_containers==TRUE){
Container_netw<-init_data$Container_netw
}
if (incl_pallets==TRUE){
Pallets_netw<-init_data$Pallets_netw
init_Areas<-init_data$init_Areas
}
if (incl_containers==TRUE){
cat("\n Calculating Probability of Introduction by container for each node \n")
Container_netw[,Pi_container:=f_container(numContainers,Cont_parameter)]
set(Container_netw, j=which(colnames(Container_netw) %in% c("numContainers")), value=NULL )
#Associate container probabilities to nodes
setkey(Container_netw,FromNode)
setkey(road_netw,FromNode)
road_netw<-merge(road_netw,Container_netw,by="FromNode",all.x=T) # adding container state of FromNo
road_netw[,stateFromNode:=Pi_container]
set(Container_netw, j=which(colnames(Container_netw) %in% c("Pi_container")), value=NULL )
names(Container_netw)[1]<-c("ToNode")
setkey(Container_netw,ToNode)
setkey(road_netw,ToNode)
road_netw<-merge(road_netw,Container_netw,by="ToNode",all.x=T) # adding container state of ToNode
road_netw[,stateToNode:=Pi_container]
#Filling NAs (some nodes are only from_nodes ot to_nodes, or are not in the Cargo Areas)
road_netw[is.na(stateFromNode),stateFromNode:=0]
road_netw[is.na(stateToNode),stateToNode:=0]
} else {
road_netw[,Pi_container:=0]
}
setkey(road_netw,FromNode)
init_nodes <- road_netw[ID%in%init_segm,c(FromNode,ToNode)] # new
road_netw[FromNode%in%init_nodes,stateFromNode:=1]
road_netw[ToNode%in%init_nodes,stateToNode:=1]
if (incl_natural){
road_netw[,p_natural:=f_natural(Length,parameters[nparset,"nat1"],parameters[nparset,"nat2"] )]
}
if (incl_attachment) {
road_netw[,p_attach:=f_attach(Length,parameters[nparset,"att1"],parameters[nparset,"att2"],parameters[nparset,"att3"])]
road_netw[grep("S",road_netw$ID),p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"S_att0"])]
road_netw[grep("R",road_netw$ID),p_attach:= 1-(1-p_attach)^(Traffic*parameters[nparset,"R_att0"])]
}
if (incl_airflow) {
road_netw[,p_airflow:=f_airflow(Length,parameters[nparset,"air1"],parameters[nparset,"air2"])]
road_netw[grep("S",road_netw$ID),p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"S_air0"])] # new
road_netw[grep("R",road_netw$ID),p_airflow:= 1-(1-p_airflow)^(Traffic*parameters[nparset,"R_air0"])]
}
road_netw[, Pi:=1-Reduce("*", 1-.SD), .SDcols=grep("p_",colnames(road_netw))] # new solution
if(incl_pallets==TRUE){
cat("\n Calculating Probability of Introduction for each Cargo area \n")
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
}
Pallets_netw
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
ind
summary(Pallets_netw$stateFromArea)
Pallets_netw$FromArea%in%init_Areas
which(Pallets_netw$FromArea%in%init_Areas)
init_Areas
which(Cargo_shp@data$AreaID%in%init_Areas)
CargoShp<-readOGR("C:/Users/mbagnara/Dropbox/AlienSpeciesSpread/Data/CargoFlows",layer="DModell_SSP_7334.cpg")
CargoShp<-readOGR("C:/Users/mbagnara/Dropbox/AlienSpeciesSpread/Data/CargoFlows",layer="DModell_SSP_7334")
which(CargoShp@data$codeSSPD%in%init_Areas)
which(CargoShp@data$codeLfdnr%in%init_Areas)
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
init_coords2<-init_coords
coordinates(init_coords2)<- ~ Long+Lat
proj4string(init_coords2)<-proj4string(CargoAreas)
over(init_coords2,CargoAreas)
which(CargoShp@data$codeLfdnr%in%init_Areas$AreaID)
which(CargoShp@data$codeSSPD%in%init_Areas$AreaID)
init_Areas<-over(init_coords2,CargoAreas)$AreaID
init_Areas
init_Areas<-as.character(over(init_coords2,CargoAreas)$AreaID)
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newArrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
ind
which(Pallets_netw$stateFromArea>0)
Pallets_netw[FromArea%in%init_Areas,]
init_Areas
Pallets_netw[init_Areas%in%FromArea,]
Pallets_netw[FromArea%in%init_Areas,]
CargoShp@data$codeLfdnr%in%init_Areas
whichCargoShp@data$codeLfdnr%in%init_Areas)
which(CargoShp@data$codeLfdnr%in%init_Areas)
which(CargoShp@data$codeSSPD%in%init_Areas)
which(CargoAreas%in%init_Areas)
which(CargoAreas$AreaID%in%init_Areas)
#load pallet flow
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
which(Pallets_netw$FromArea%in%init_Areas
)
CargoAreas<-CargoShp
init_coords2<-init_coords
coordinates(init_coords2)<- ~ Long+Lat
proj4string(init_coords2)<-proj4string(CargoAreas)
init_Areas<-over(init_coords2,CargoAreas)
init_Areas
init_Areas<-as.character(over(init_coords2,CargoAreas)$codeLfdnr)
init_Areas
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newArrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
ind
CargoAreas<-CargoShp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell,NodesCoords@data$nodeID))
colnames(Nodes_CargoCell)<-c("AreaCont","AreaPallet","Node")
colnames(CargoShp)<-c("AreaContainer","AreaPallet")
colnames(CargoShp@data)<-c("AreaContainer","AreaPallet")
Cargo_shp<-CargoShp
devtools::use_data(Cargo_shp,overwrite = T)
CargoAreas<-Cargo_shp #need to update to provide external file here. Perhaps also in network file?
NodesCoords<-getNodesCoord(roads_shp)
coordinates(NodesCoords)<- ~ Long+Lat
proj4string(NodesCoords)<-proj4string(CargoAreas)
Nodes_CargoCell<-over(NodesCoords,CargoAreas)
Nodes_CargoCell<-as.data.table(cbind(Nodes_CargoCell$AreaContainer,NodesCoords@data$nodeID))
colnames(Nodes_CargoCell)<-c("Area","Node")
Nodes_CargoCell
init_coords2<-init_coords
coordinates(init_coords2)<- ~ Long+Lat
proj4string(init_coords2)<-proj4string(CargoAreas)
init_Areas<-as.character(over(init_coords2,CargoAreas)$codeLfdnr)
init_Areas
init_coords2<-init_coords
coordinates(init_coords2)<- ~ Long+Lat
proj4string(init_coords2)<-proj4string(CargoAreas)
over(init_coords2,CargoAreas)
init_Areas<-as.character(over(init_coords2,CargoAreas)$AreaPallet)
init_Areas
#load pallet flow
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newArrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
ind
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:=   1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToNode] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToNode] # update ToNodes with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToNode] # update ToNodes with old and new state
newstate <- unique(Pallets_netw[ind,c("ToNode","stateToArea")],by="ToNode") # extract new state of ToNodes to update FromNodes states
setnames(newstate,c("FromNode","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromNode)
setkey(Pallets_netw,FromNode)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromNode",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromNodes states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromNodes
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:=   1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromAreas states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromAreas
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
Pallets_netw
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newarrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
Pallets_netw
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:=   1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromAreas states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromAreas
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
Pallets_netw
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newarrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:=   1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:=   1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
#Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
newstate
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
Pallets_netw
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newarrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw
Pallets_netw[ind,]
summary(Pallets_netw[ind,newarrivals])
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,10)] #parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:= 1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,]
source('~/GitHub/AlienSpeciesSpread/CASPIAN/inst/extdata/configFile.R', encoding = 'UTF-8', echo=TRUE)
parameters<-matrix(c(par_att0_Roads,par_att0_Railways,par_att1,par_att2,par_att3,par_air0_Roads,par_air0_Railways,par_air1,par_air2,par_nat1,par_nat2,par_est,par_cont,par_pall),nrow=1,byrow=T)
colnames(parameters)<-c("S_att0", "R_att0","att1","att2","att3","S_air0","R_air0", "air1","air2","nat1","nat2","est0","cont1","pall1")
#build land cover species preference matrix
species_preferences<- data.table(LC_cat_ID= 1:5,Species_preferences=c(Urban_areas,Arable_land,Pastures,Forests,Wetlands))
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
#load pallet flow
Pallets_netw<-as.data.table(PalletsFlow) #need to update to provide external file here. Perhaps also in network file?
Pallets_netw<-Pallets_netw[FromArea!=ToArea,]
Pallets_netw[,numPallets:=numPallets/12] #monthly scale
#assign Area LinkIDs
Pallets_netw[,AreaLinkID:=paste(FromArea,ToArea,sep="_")]
# initialize state of Cargo Areas
Pallets_netw[,stateFromArea:=0]
Pallets_netw[,stateToArea:=0]
Pallets_netw[,newarrivals:=0]
# Update initial state of Cargo Areas
Pallets_netw[FromArea%in%init_Areas,stateFromArea:=1]
Pallets_netw[ToArea%in%init_Areas,stateToArea:=1]
#Assigning probability to Cargo links for Pallets,
#using same kernel than containers with different parameterization:
Pallets_netw[,Pi_pallet:=f_container(numPallets,parameters[nparset,"pall1"])]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,newarrivals:= 1-prod(1-(stateFromArea * Pi_pallet )) ,by=ToArea] # calculate pintro for each link
Pallets_netw[ind,stateToArea:=1-(prod((1-stateToArea) * (1-newarrivals))),by=ToArea] # update ToAreas with old and new state
Pallets_netw[,stateToArea:=1-(prod((1-stateToArea))),by=ToArea] # update ToAreas with old and new state
newstate <- unique(Pallets_netw[ind,c("ToArea","stateToArea")],by="ToArea") # extract new state of ToAreas to update FromAreas states
setnames(newstate,c("FromArea","newstate")) # prepare file for merge (set names and key)
setkey(newstate,FromArea)
setkey(Pallets_netw,FromArea)
Pallets_netw <- merge(Pallets_netw,newstate,by="FromArea",all.x=T)
# Pallets_netw <- newstate[Pallets_netw] # merge Pallets_netw and newstate to update FromAreas states
Pallets_netw[newstate>0 ,stateFromArea:=newstate] # assigne new states to FromAreas
Pallets_netw[,newstate:=NULL] # remove column to avoid columns with the same names
Pallets_netw[ind,]
ind
Pallets_netw[ind,]
ind <- which(Pallets_netw$stateFromArea>0 & Pallets_netw$stateToArea<1) # select links with non-empty start node and non-filled end node
Pallets_netw[ind,]
