# ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
#        no = pars <- ListPar(t(as.matrix(pars))))
# ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
#        no = parameterList <- pars)
#
outputCASPIAN <- SpreadModel(parameters=p,internal_dataset=internal_dataset,road_type=road_type,
initialize = FALSE, save_init = FALSE, file_init = file_init,
init_coords=init_coords, num_iter=num_iter,max_dist = 10^4,
incl_attachment=incl_attachment,incl_airflow=incl_airflow, incl_natural=incl_natural,
species_preferences=species_preferences,
makeplot = TRUE,save_plot=FALSE,iter_save = iter_save
)
#
# if (parallelOption == FALSE) {
#   parameterList <- pars
#   outputLPJ <- list(outputLPJ)
#
nruns <- 1
# } else nruns <- length(parameterList)
#
likelihoods <- c()
#needs cycle over list elements somewhere!!
for (nparticles in 1:nruns) {
sumll <- NA
for (nsteps in 1:length(outputCASPIAN)){
predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
observed <- InvasionData[[nsteps]]
llobj <- merge(observed, predicted, all = FALSE,
by = "ID")
res <- llobj$Pinv - llobj$Pinv_obs
# err <- as.numeric(p[nparticles, grep(out,colnames(p))])
err <- llobj$Pinv_obs*0.1
x <- dnorm(res, sd = err,
log = T)
sumll <- sum(sumll, x, na.rm = TRUE)
}
likelihoods[nparticles] <- sumll
}
return(likelihoods)
}
#creat BCsetup
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = TRUE, names = parNames)
iterations = 100
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#define likelihood function
likelihoodCASPIAN <- function(parameters) {
parameters<-BCsetup$prior$sampler(1)
if (is.vector(parameters))
parameters = matrix(parameters, nrow = 1)
p <- matrix(NA, nrow = nrow(parameters), ncol = length(defaultValues))
for (i in 1:nrow(parameters)) p[i, ] <- createMixWithDefaults(parameters[i,
1:ncol(parameters)], defaultValues, parSel)
colnames(p) <- colnames(defaultValues)
# nerr <- length(grep("errpar", colnames(p)))
# pars <- p[, -tail(1:ncol(p), nerr)]
# ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
#        no = pars <- ListPar(t(as.matrix(pars))))
# ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
#        no = parameterList <- pars)
#
outputCASPIAN <- SpreadModel(parameters=p,internal_dataset=internal_dataset,road_type=road_type,
initialize = FALSE, save_init = FALSE, file_init = file_init,
init_coords=init_coords, num_iter=num_iter,max_dist = 10^4,
incl_attachment=incl_attachment,incl_airflow=incl_airflow, incl_natural=incl_natural,
species_preferences=species_preferences,
makeplot = FALSE,save_plot=FALSE,iter_save = iter_save
)
#
# if (parallelOption == FALSE) {
#   parameterList <- pars
#   outputLPJ <- list(outputLPJ)
#
nruns <- 1
# } else nruns <- length(parameterList)
#
likelihoods <- c()
#needs cycle over list elements somewhere!!
for (nparticles in 1:nruns) {
sumll <- NA
for (nsteps in 1:length(outputCASPIAN)){
predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
observed <- InvasionData[[nsteps]]
llobj <- merge(observed, predicted, all = FALSE,
by = "ID")
res <- llobj$Pinv - llobj$Pinv_obs
# err <- as.numeric(p[nparticles, grep(out,colnames(p))])
err <- llobj$Pinv_obs*0.1
x <- dnorm(res, sd = err,
log = T)
sumll <- sum(sumll, x, na.rm = TRUE)
}
likelihoods[nparticles] <- sumll
}
return(likelihoods)
}
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = TRUE, names = parNames)
iterations = 100
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = FALSE, names = parNames)
iterations = 100
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
warnings()
#define likelihood function
likelihoodCASPIAN <- function(parameters) {
parameters<-BCsetup$prior$sampler(1)
if (is.vector(parameters))
parameters = matrix(parameters, nrow = 1)
p <- matrix(NA, nrow = nrow(parameters), ncol = length(defaultValues))
for (i in 1:nrow(parameters)) p[i, ] <- suppressWarnings(createMixWithDefaults(parameters[i,
1:ncol(parameters)], defaultValues, parSel)
)
colnames(p) <- colnames(defaultValues)
# nerr <- length(grep("errpar", colnames(p)))
# pars <- p[, -tail(1:ncol(p), nerr)]
# ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
#        no = pars <- ListPar(t(as.matrix(pars))))
# ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
#        no = parameterList <- pars)
#
outputCASPIAN <- SpreadModel(parameters=p,internal_dataset=internal_dataset,road_type=road_type,
initialize = FALSE, save_init = FALSE, file_init = file_init,
init_coords=init_coords, num_iter=num_iter,max_dist = 10^4,
incl_attachment=incl_attachment,incl_airflow=incl_airflow, incl_natural=incl_natural,
species_preferences=species_preferences,
makeplot = FALSE,save_plot=FALSE,iter_save = iter_save
)
#
# if (parallelOption == FALSE) {
#   parameterList <- pars
#   outputLPJ <- list(outputLPJ)
#
nruns <- 1
# } else nruns <- length(parameterList)
#
likelihoods <- c()
#needs cycle over list elements somewhere!!
for (nparticles in 1:nruns) {
sumll <- NA
for (nsteps in 1:length(outputCASPIAN)){
predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
observed <- InvasionData[[nsteps]]
llobj <- merge(observed, predicted, all = FALSE,
by = "ID")
res <- llobj$Pinv - llobj$Pinv_obs
# err <- as.numeric(p[nparticles, grep(out,colnames(p))])
err <- llobj$Pinv_obs*0.1
x <- dnorm(res, sd = err,
log = T)
sumll <- sum(sumll, x, na.rm = TRUE)
}
likelihoods[nparticles] <- sumll
}
return(likelihoods)
}
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = TRUE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
plot(resDE)
?mapply
?rescale
SenecioData<-as.data.table(read.table("C:/Users/mbagnara/Dropbox/AlienSpeciesSpread/Data/AlienSpecies/Senecio_FrankSchurr/Senecio inaequidens spread data.txt",h=T))
#Set initial points of invasion
Bremen<- data.frame(Latitude=53.09, Longitude=08.78)
Calais <- data.frame(Latitude=50.97, Longitude=01.90)
Verviers<- data.frame(Latitude=50.59, Longitude=05.85)
Mazamet<-data.frame(Latitude=43.50, Longitude=02.37)
init_Inv_Senecio<-rbind(Bremen,Calais,Verviers,Mazamet)[,c(2,1)]
countryList<-c("D","NL","B","CH","A","F")
init_year<-1990
init_Locations<-SenecioData[(Year.of.first.record<init_year & Country%in%countryList),
c("Population","Longitude","Latitude","Country")]
init_coords_senecio<-rbind(init_Inv_Senecio,init_Locations[,c("Longitude","Latitude")])
init_coords_senecio[,iter:=0]
#Set landcover IDs suitable for establishment
Suitable_LandCoverID<-c(10:11,12:29) #select all and it should not make a difference
last_year<-max(SenecioData$Year.of.first.record)
num_iter<- c(last_year-init_year)*12 # simulation steps, monthly scale
#set according to years of data availability!
# e.g. starting in 1980, town invaded in 1990, iter. 120 should be included (monthly scale, 10 years)
iter_save <- round(c(1,seq(12,num_iter,by = 12)),0)
# set road types to be considered (default is all).
# Including more than "A" and "B" does NOT speed up the calculations significantly
road_type <- c("A","B","L","S")
#SET DATA POINTS HERE:
# 1) get locations invaded after init_year
data_Locations<-SenecioData[(Year.of.first.record>=init_year & Country=="D"),
c("Year.of.first.record","Longitude","Latitude","Country")]
IterToEvaluate<-(data_Locations$Year.of.first.record-init_year)*12
data_Locations[,iter:=IterToEvaluate]
data_coords_senecio<- data_Locations[,c("Longitude","Latitude","iter")]
data_coords_senecio
init_Inv_Senecio
data_Locations
init_Locations
#Set initial points of invasion
Bremen<- data.frame(Latitude=53.09, Longitude=08.78)
Calais <- data.frame(Latitude=50.97, Longitude=01.90)
Verviers<- data.frame(Latitude=50.59, Longitude=05.85)
Mazamet<-data.frame(Latitude=43.50, Longitude=02.37)
init_Inv_Senecio<-rbind(Bremen,Calais,Verviers,Mazamet)[,c(2,1)]
countryList<-c("D","NL","B","CH","A","F")
init_year<-1990
init_Locations<-SenecioData[(Year.of.first.record<=init_year & Country%in%countryList),
c("Population","Longitude","Latitude","Country")]
init_coords_senecio<-rbind(init_Inv_Senecio,init_Locations[,c("Longitude","Latitude")])
init_coords_senecio[,iter:=0]
data_Locations<-SenecioData[(Year.of.first.record>init_year & Country=="D"),
c("Year.of.first.record","Longitude","Latitude","Country")]
IterToEvaluate<-(data_Locations$Year.of.first.record-init_year)*12
data_Locations[,iter:=IterToEvaluate]
data_coords_senecio<- data_Locations[,c("Longitude","Latitude","iter")]
data_coords_senecio
### CASPIAN CALIBRATION SCRIPT
rm(list=ls())
graphics.off()
library(CASPIAN)
library(BayesianTools)
mainDir<-"C:/Users/mbagnara/Desktop/BiK-F postDoc/Model/Senecio/"
# mainDir<-"/home/hanno/Bioinvasion/EBAspread/Model"
setwd(mainDir)
#reading configuration file
configFile<-file.path(mainDir,"configFileSenecio.R")
source(configFile)
ls()
### CASPIAN CALIBRATION SCRIPT
rm(list=ls())
graphics.off()
library(CASPIAN)
library(BayesianTools)
mainDir<-"C:/Users/mbagnara/Desktop/BiK-F postDoc/Model/Senecio/"
# mainDir<-"/home/hanno/Bioinvasion/EBAspread/Model"
setwd(mainDir)
#reading configuration file
configFile<-file.path(mainDir,"configFileSenecio.R")
source(configFile)
#build land cover species preference matrix
species_preferences<- data.table(LC_cat_ID= 1:5,Species_preferences=c(Urban_areas,Arable_land,Pastures,Forests,Wetlands))
# build parameter matrix
parameters<-matrix(c(par_att0,par_att1,par_att2,par_att3,par_air1,par_air2,par_nat1,par_nat2,par_est,par_air0),nrow=1,byrow=T)
colnames(parameters)<-c("att0", "att1","att2","att3", "air1","air2","nat1","nat2","est0","air0")
# get default values and select which parameters to calibrate
defaultValues <- parameters
# for (i in ls()[grep("errpar", ls())]) defaultValues <- c(defaultValues, get(i))  #Commented, avoid likelihood sd if possible
# for (i in rownames(parameterStandard)) {
#   defaultValues[i] <- parameterStandard[rownames(parameterStandard) ==
#                                           i]
# }
parNames <- c("att0","air0")
parSel <- c()
for (i in parNames) parSel <- c(parSel, grep(i, colnames(defaultValues)))
parValues <- c(defaultValues[parSel])
npar <- length(parValues)
#define prior range
PriorRange<-data.frame(name=parNames,min_range=parValues-parValues*.5,default=parValues,max_range=parValues+parValues*.5)
# build priors
prior.min <- c()
prior.max <- c()
for (i in 1:npar) {
prior.min[i] <- c(PriorRange$min_range[which(PriorRange$name ==
parNames[i])])
prior.max[i] <- c(PriorRange$max_range[which(PriorRange$name ==
parNames[i])])
}
prior <- createTruncatedNormalPrior(lower = prior.min, upper = prior.max,
mean = parValues, sd=parValues*0.1)
#par(mfrow=c(2,2))
priorSample<-BCsetup$prior$sampler(1000)
for (i in 1:npar) {
hist(priorSample[,i], main=PriorRange$name[i], xlim=c(PriorRange$min_range[i],PriorRange$max_range[i]))
abline(v=PriorRange$default[i], col="red")
}
# get Invasion Data
data_Locations<-SenecioData[(Year.of.first.record>init_year & Country=="D"),
c("Year.of.first.record","Longitude","Latitude","Country")]
IterToEvaluate<-(data_Locations$Year.of.first.record-init_year)*12
data_Locations[,iter:=IterToEvaluate]
data_coords_senecio<- data_Locations[,c("Longitude","Latitude","iter")]
InvasionData<-list()
for (i in 1:nrow(data_coords_senecio)) {
#calculate invaded links as an initialization,
ID<-InitializeSpread(init_coords=data_coords_senecio[,1:2],max_dist=10^4,
road_type=road_type,save_init=FALSE,
species_preferences=species_preferences)$init_segm
# associate probability (ideally decaying with distance from data coordinates, later step?)
linkProb<-data.frame(Pinv_obs=0.9,ID)
#add as element list
InvasionData[[as.character(data_coords_senecio[i,3])]]<-linkProbFrankfurt
}
InvasionData<-list()
for (i in 1:nrow(data_coords_senecio)) {
#calculate invaded links as an initialization,
ID<-InitializeSpread(init_coords=data_coords_senecio[,1:2],max_dist=10^4,
road_type=road_type,save_init=FALSE,
species_preferences=species_preferences)$init_segm
# associate probability (ideally decaying with distance from data coordinates, later step?)
linkProb<-data.frame(Pinv_obs=0.9,ID)
#add as element list
InvasionData[[as.character(data_coords_senecio[i,3])]]<-linkProb
}
#set num_iter as long as necessary, and iter_save for appropriate comparison:
iter_save<-as.numeric(names(InvasionData))
num_iter<-max(iter_save)
#initialize CASPIAN
init_data<-InitializeSpread(init_coords=init_coords_senecio,max_dist=10^4,
road_type=road_type,save_init=T, save_dir=mainDir,file_init=file_init,
species_preferences=species_preferences)
rm(init_data)
init_file<-file.path(mainDir,file_init)
#define likelihood function
likelihoodCASPIAN <- function(parameters) {
parameters<-BCsetup$prior$sampler(1)
if (is.vector(parameters))
parameters = matrix(parameters, nrow = 1)
p <- matrix(NA, nrow = nrow(parameters), ncol = length(defaultValues))
for (i in 1:nrow(parameters)) p[i, ] <- suppressWarnings(createMixWithDefaults(parameters[i,
1:ncol(parameters)], defaultValues, parSel)
)
colnames(p) <- colnames(defaultValues)
# nerr <- length(grep("errpar", colnames(p)))
# pars <- p[, -tail(1:ncol(p), nerr)]
# ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
#        no = pars <- ListPar(t(as.matrix(pars))))
# ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
#        no = parameterList <- pars)
#
outputCASPIAN <- SpreadModel(parameters=p,internal_dataset=internal_dataset,road_type=road_type,
initialize = FALSE, save_init = FALSE, file_init = file_init,
init_coords=init_coords_senecio, num_iter=num_iter,max_dist = 10^4,
incl_attachment=incl_attachment,incl_airflow=incl_airflow, incl_natural=incl_natural,
species_preferences=species_preferences,
makeplot = FALSE,save_plot=FALSE,iter_save = iter_save
)
#
# if (parallelOption == FALSE) {
#   parameterList <- pars
#   outputLPJ <- list(outputLPJ)
#
nruns <- 1
# } else nruns <- length(parameterList)
#
likelihoods <- c()
#needs cycle over list elements somewhere!!
for (nparticles in 1:nruns) {
sumll <- NA
for (nsteps in 1:length(outputCASPIAN)){
predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
observed <- InvasionData[[nsteps]]
llobj <- merge(observed, predicted, all = FALSE,
by = "ID")
res <- llobj$Pinv - llobj$Pinv_obs
# err <- as.numeric(p[nparticles, grep(out,colnames(p))])
err <- llobj$Pinv_obs*0.1
x <- dnorm(res, sd = err,
log = T)
sumll <- sum(sumll, x, na.rm = TRUE)
}
likelihoods[nparticles] <- sumll
}
return(likelihoods)
}
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = TRUE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
BCsetup
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = FALSE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = TRUE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = FALSE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
#define likelihood function
likelihoodCASPIAN <- function(parameters) {
parameters<-BCsetup$prior$sampler(1)
if (is.vector(parameters))
parameters = matrix(parameters, nrow = 1)
p <- matrix(NA, nrow = nrow(parameters), ncol = length(defaultValues))
for (i in 1:nrow(parameters)) p[i, ] <- suppressWarnings(createMixWithDefaults(parameters[i,
1:ncol(parameters)], defaultValues, parSel)
)
colnames(p) <- colnames(defaultValues)
# nerr <- length(grep("errpar", colnames(p)))
# pars <- p[, -tail(1:ncol(p), nerr)]
# ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
#        no = pars <- ListPar(t(as.matrix(pars))))
# ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
#        no = parameterList <- pars)
#
invisible(capture.output(
outputCASPIAN <- SpreadModel(parameters=p,internal_dataset=internal_dataset,road_type=road_type,
initialize = FALSE, save_init = FALSE, file_init = file_init,
init_coords=init_coords_senecio, num_iter=num_iter,max_dist = 10^4,
incl_attachment=incl_attachment,incl_airflow=incl_airflow, incl_natural=incl_natural,
species_preferences=species_preferences,
makeplot = FALSE,save_plot=FALSE,iter_save = iter_save
)
))
#
# if (parallelOption == FALSE) {
#   parameterList <- pars
#   outputLPJ <- list(outputLPJ)
#
nruns <- 1
# } else nruns <- length(parameterList)
#
likelihoods <- c()
#needs cycle over list elements somewhere!!
for (nparticles in 1:nruns) {
sumll <- NA
for (nsteps in 1:length(outputCASPIAN)){
predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
observed <- InvasionData[[nsteps]]
llobj <- merge(observed, predicted, all = FALSE,
by = "ID")
res <- llobj$Pinv - llobj$Pinv_obs
# err <- as.numeric(p[nparticles, grep(out,colnames(p))])
err <- llobj$Pinv_obs*0.1
x <- dnorm(res, sd = err,
log = T)
sumll <- sum(sumll, x, na.rm = TRUE)
}
likelihoods[nparticles] <- sumll
}
return(likelihoods)
}
#create BCsetup and calibration settings
BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior,
parallel = FALSE, names = parNames)
iterations = 10
start = BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart = list(start[1:3, ], start[4:6, ], start[7:9,
])
BCsettings <- list(iterations = iterations, nrChains = 3,
startValue = DEStart, consoleUpdates = 1)
#run calibration
resDE <- runMCMC(BCsetup, sampler = "DEzs", settings = BCsettings)
